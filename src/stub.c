/* stub.c
qode.exe that is generated by webpack is very sensitive about it's cwd for some
annoying reason. To get around this, first within the executable javascript
we're going to detect if the SETCWD environment variable is set and then change
directories within the process.

Q: Why not just pass the desired working directory as a command line argument?
A: Well qode seems to apparently not like that either for some reason.

Q: Why not have something within the GUI that allows you to change directories?
A: Good question, it's because right now, I don't really know how to code the
   file selector thing. Maybe when I get around to it, I'll do that. It seems
   like a better solution than this horrible hack that I'm having to do here.
   Admittedly, I didn't actually think of doing this before I wrote stub.c so
   the above is justification after the fact.
A: Actually, stub.c solves a different problem than being able to change working
   directories after launch. I think both solutions are good.

Q: Why is the code below so... bad?
A: Writing hobby code normally is kinda lame and boring. Extreme programming is
   more enjoyable. I mean in the first place, this silly file could be replaced
   with like a single batch script, I think. But that wouldn't be any fun, would
   it?
*/
#define WIN32_LEAN_AND_MEAN
#include <windows.h>

// yes this has to be here since it gets zero initialized lol
STARTUPINFOW si;

int wmain(int argc, wchar_t *argv[]) {
   wchar_t *dirname;
   DWORD dirname_len = 0; // not including the null byte
   {
      /*
      So the way this is going to work is simple. The generated executable for
      stub.c (probably fs_date_archivist.exe) is going to remain in the same
      directory as the rest of the compiled output. Unlike, qode.exe, however, I
      will be using argv[0] to determine location of the compiled things.

      The code in here is to get the equivalent of __dirname.
      */

      dirname = argv[0];

      #define is_path_separator(c) (c == L'\\' || c == L'/')

      for (size_t i = 0; dirname[i] != '\0'; ++i) {
         if (is_path_separator(dirname[i])) {
            dirname_len = i + 1;
         }
      }

      // if the invocation is something like
      // P:/rogram_files/fs_date_archivist/fs_date_archivist.exe
      //                       dirname_len ^ == f

      // when the loop stops, dirname[dirname_len] is the character after the
      // last slash.

      dirname[dirname_len] = L'\0';
   }

   wchar_t *qode_exe = _alloca(
      sizeof(wchar_t) * dirname_len + sizeof(L"qode.exe")
   );
   {
      // qode_exe = "P:/rogram_files/fs_date_archivist/"
      __builtin_memcpy(qode_exe, dirname, sizeof(wchar_t) * dirname_len);
      // qode_exe += "qode.exe\0"
      __builtin_memcpy(qode_exe + dirname_len, L"qode.exe", sizeof(L"qode.exe"));
   }

   // Slightly cursed API:
   // Calling this with 0, NULL actually returns the length of the cwd path
   // including the null byte. I'm pretty sure this is in characters and not
   // bytes but you can never be too careful.
   DWORD cwd_len = GetCurrentDirectoryW(0, NULL);

   // alright next is creating the environment string
   // the memory layout is going to look like `SETCWD=cwd\0\0`
   DWORD env_len = sizeof("SETCWD=") - sizeof("") + cwd_len + sizeof("");
   wchar_t *env = _alloca(env_len * sizeof(wchar_t));
   env[env_len - 1] = '\0';
   __builtin_memcpy(env, L"SETCWD=", sizeof(L"SETCWD=") - sizeof(L""));
   GetCurrentDirectoryW(cwd_len, env + sizeof("SETCWD=") - sizeof(""));

   PROCESS_INFORMATION pi;
   CreateProcessW(
      qode_exe,                   // lpApplicationName
      NULL,                       // lpCommandLine
      NULL,                       // lpProcessAttributes
      NULL,                       // lpThreadAttributes
      1,                          // bInheritHandles
      CREATE_UNICODE_ENVIRONMENT, // dwCreationFlags
      env,                        // lpEnvironment
      dirname,                    // lpCurrentDirectory
      &si,                        // lpStartupInfo
      &pi                         // lpProcessInformation
   );
}
